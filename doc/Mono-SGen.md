Unity 不支持 SGen 算法，以后也不打算支持了。
Mono 是一个开源的.Net 框架实现，SGen 是其内存的垃圾收集器之一。SGen 采用分代垃圾收集算法，旨在提高性能和减少垃圾收集应用程序的影响。分析 SGen 的源码可以帮助我们更好地理解其工作原理和实现细节。

# 1. 源码结构

Mono 地源码可以在 Github 上找到，SGen 地相关代码主要位于`mono/mono/sgen`目录下。以下是一些关键文件和目录：

- `sgen-gc.c`：SGen 的主要实现文件，包含垃圾收集的核心逻辑。
- `sgen-marksweep.c`：标记-清除算法的实现。
- `sgen-major-copying.c`：老年代复制算法的实现。
- `sgen-nursery-collector.c`：年轻代垃圾收集的实现。
- `sgen-pinning.c`：对象固定（pinning）相关的实现。
- `sgen-scan-object.c`：对象扫描相关的实现。
- `sgen-gc.h`：SGen 的头文件，定义了主要的数据结构和函数接口。

# 2. 初始化

SGen 的初始化过程在`sgen-gc.c`文件中实现。主要步骤包括：

1. 内存分配：为垃圾收集器分配所需的内存，包括堆、卡表（card table）等。
2. 数据结构初始化：初始化各种数据结构，如对象描述符、根集等。
3. 线程管理：创建和管理用于并发垃圾收集的线程。

```c
void
sgen_init (void)
{
  // 初始化内存分配器
  sgen_mem_init();

  // 初始化卡表
  sgen_cardtable_init();

  // 初始化根集
  sgen_init_root_sets ();

  // 初始化并发垃圾收集线程
  sgen_concurrent_init();

  // 其他初始化操作
  ...
}
```

# 3. 年轻代垃圾收集

年轻代垃圾收集主要在`sgen-nursery-collector.c`文件中实现。SGen 使用复制算法啦回收年轻代对象。主要步骤包括：

1. 标记阶段：标记从根对象可达的年轻代对象。
2. 复制阶段：将存活的对象从当前区域复制到新的区域。
3. 更新引用：更新所有指向旧区域的引用，使其指向新区域中的对象。

```c
void
sgen_collect_nurserg(void)
{
  // 标记阶段
  sgen_mark_from_roots ();

  // 复制阶段
  sgen_copy_surviviing_objects ();

  // 更新引用
  sgen_update_references ();

  // 其他操作
  ...
}
```

# 4. 老年代垃圾收集

老年代垃圾收集主要在`sgen-major-copying.c`和`sgen-marksweep.c`文件中实现。SGen 支持多种老年代垃圾收集算法，包括标记-清除和标记-压缩。主要步骤包括：

1. 标记阶段：标记从更对象和年轻对象可达的老年代对象。
2. 清除阶段：回收未标记的对象，释放内存。
3. 压缩阶段（可选）：将存活的对象压缩到内存的一端，以减少内存碎片。

```c
void
sgen_collect_major (void)
{
  // 标记阶段
  sgen_mark_from_roots ();

  // 清除阶段
  sgen_sweep ();

  // 压缩阶段（可选）
  sgen_compact ();

  // 其他操作
  ...
}
```

# 5. 并发垃圾收集

SGen 支持并发垃圾收集，可以在应用程运行时进行垃圾收集，从而减少暂停时间。并发垃圾收集的主要步骤包括：

1. 初始标记：暂停应用程序，标记从根对象可达的对象。
2. 并发标记：在应用程序继续运行的同时，标记从初始标记阶段标记的对象可达的所有对象。
3. 重新标记：暂停应用程序，标记在并发标记阶段新创建或修改的对象。
4. 并发清除：在应用程序继续运行的同时，回收未标记的对象。

```c
void
sgen_concurrent_collect (void)
{
  // 初始标记
  sgen_initial_mark ();
  // 并发标记
  sgen_concurrent_mark ();
  // 重新标记
  sgen_final_mark();

  // 并发清除
  sgen_concurrent_sweep ();

  // 其他操作
  ...
}
```

# 6. 写屏障（Write Barrier）

为了支持分代和并发垃圾收集，SGen 使用写屏障机制。写屏障是一种在对象引用被修改时执行的代码，用于跟踪对象引用的变化。写屏障的实现主要在`sgen-gc.c`文件中。

```c
void
sgen_write_barrier (void *obj, void *value)
{
  // 更新卡表
  sgen_cardtable_update (obj, value);

  // 其他操作
  ...
}
```

# 卡表

卡表（Card Table）是一种用于优化垃圾收集器性能的数据结构，特别是在分代垃圾收集器中。它的主要作用是跟踪老年代对象对年轻代对象的引用，从而减少垃圾收集过程中需要扫描的对象数量。

## 为什么需要卡表？

在分代垃圾收集器中，堆内存通常被分为年轻代和老年代。年轻代对象生命周期短，频繁回收；老年代对象生命周期长，较少回收。为了提高垃圾收集效率，年轻代和老年代的垃圾收集通常是分开进行的。

然而，老年代对象可能会引用年轻代对象。在进行年轻代垃圾收集时，需要确保这些引用的年轻代对象不会被错误地回收。直接扫描整个老年代来查找这些引用是非常低效地，因此引入了卡表来优化这一过程。

## 卡表的工作原理

卡表将堆内存划分为固定大小的卡片（Card），每个卡片对应一个卡表条目。卡表条目是一个布尔值或标志位，表示该卡表是否包含对年轻代对象的引用。

- 卡片（Card）：堆内存被划分未多个固定大小的区域，每个区域成为一个卡片。
- 卡表条目（Card Table Entry）：每个卡片对应一个卡表条目，记录该卡片是否包含对年轻代对象的引用。

## 写屏障与卡表

写屏障（Write Barrier）是垃圾收集器在对象引用被修改时执行的代码。写屏障的主要作用是更新卡表。当老年代对象引用年轻代对象时，写屏障会将对应的卡表条目标记为“脏”（Dirty），表示该卡片包含对年轻代对象的引用。

```c
void
sgen_write_barrier (void *obj, void *value)
{
  // 更新卡表
  sgen_cardtable_update(obj, value);

  // 其他操作
  ...
}
```

## 年轻代垃圾收集与卡表

在进行年轻代垃圾收集时，垃圾收集器只需要扫描卡表中标记为“脏”的卡片，而不需要扫描整个老年代。这大大减少了需要扫描的对象数量，提高了垃圾收集的效率。

```c
void
sgen_collect_nursery (void)
{
  // 标记阶段
  sgen_mark_from_roots ();
  // 扫描卡表，标记老年代对年轻代的引用
  sgen_scan_card_table ();

  // 复制阶段
  sgen_copy_surviving_objects ();

  // 更新引用
  sgen_update_references ();

  // 其他操作
  ...
}
```

## 卡表优缺点

优点：

- 提高效率：通过减少需要扫描的对象数量，提高了垃圾收集的效率。
- 分代优化：特别适用于分代垃圾收集器，优化了年轻代垃圾收集的性能。

缺点：

- 额外内存开销：卡表需要额外的内存来存储卡片的状态。
- 写屏障开销：每次对象引用修改时，写屏障需要更新卡表，增加了一定的开销。

## 总结

卡表是一种用于优化垃圾收集器性能的数据结构，特别适用于分代垃圾收集器。它通过跟踪老年代对象和年轻代对象的引用，减少了垃圾收集过程中需要扫描的对象数量，从而提高了垃圾收集的效率，卡表的实现依赖于写屏障机制，在对象引用被修改时更新卡表的状态。尽管卡表引入了一定的内存和性能开销，但其在优化垃圾收集性能方面的优势使其成为分代垃圾收集器中的重要组件。
