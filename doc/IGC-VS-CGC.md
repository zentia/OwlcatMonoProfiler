增量垃圾收集(Incremental Garbage Collection,IGC)和并发垃圾收集(Concurrent Garbage Collection,CGC)虽然在某些方面有相似之处，单它们并不是完全相同的概念。以下是对这两者的详细比较和解释：

# 增量垃圾收集(IGC)

增量垃圾收集的主要目标是将垃圾收集过程分解为多个小步骤，以减少每次垃圾收集的暂停时间。增量垃圾收集通常在应用程序的主线程执行，但每次只执行一小部分垃圾收集工作，然后返回应用程序的正常执行。

关键特性：

1. 分阶段特性：垃圾收集过程被分解为多个小步骤，每次只执行一部分工作。
2. 减少暂停时间：通过分阶段执行，减少每次垃圾收集的暂停时间，从而提高应用程序的响应性。
3. 与应用程序交替执行：垃圾收集和应用程序的正常执行交替进行。

# 并发垃圾收集(CGC)

并发垃圾收集的主要目标是尽量减少垃圾收集对应用程序的影响。并发垃圾收集通常在独立的线程上执行，与应用程序的主线程并发执行。

关键特性：

1. 并发执行：垃圾收集在独立的线程上执行，与应用程序的主线程并发运行。
2. 最小化暂停时间：通过并发执行，尽量减少垃圾收集对应用程序的暂停时间。
3. 复杂的同步机制：需要复杂的同步机制来确保垃圾收集和应用程序的正常执行之间的数据一致性。

# Unity 增量垃圾收集 vs Mono Boehm 并发垃圾收集

Unity 的增量垃圾收集和 Mono Boehm 的并发垃圾收集在实现细节上有一些相似之处，但它们的目标和实现方式有所不同。

相似之处：

1. 减少暂停时间：两者都旨在减少垃圾收集对应用程序的暂停时间。
2. 分阶段执行：两者都将垃圾收集过程分解多个阶段，以减少每次垃圾收集的影响。

不同之处：

1. 执行方式：

   - 增量垃圾收集：在应用程序的主线程上分阶段执行，每次只执行一部分工作，然后返回应用程序的正常执行。
   - 并发垃圾收集：在独立的主线程上并发执行，与应用程序的主线程同时运行。

2. 同步机制：
   - 增量垃圾收集：需要在每个阶段之间进行同步，以确保数据一致性。
   - 并发垃圾收集：需要复杂的同步机制来处理并发执行中数据一致性问题。
